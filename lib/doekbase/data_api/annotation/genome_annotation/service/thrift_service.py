#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(Interface):
  def get_taxon(token, ref):
    """
    Retrieve the Taxon associated with this GenomeAnnotation.

    @return Reference to TaxonAPI object

    Parameters:
     - token
     - ref
    """
    pass

  def get_assembly(token, ref):
    """
    Retrieve the Assembly associated with this GenomeAnnotation.

    @return Reference to AssemblyAPI object

    Parameters:
     - token
     - ref
    """
    pass

  def get_feature_types(token, ref):
    """
    Retrieve the list of Feature types.

    @return List of feature type identifiers (strings)

    Parameters:
     - token
     - ref
    """
    pass

  def get_feature_type_descriptions(token, ref, feature_type_list):
    """
    Retrieve the descriptions for each Feature type in
    this GenomeAnnotation.

    @param feature_type_list List of Feature types. If this list
     is empty or None,
     the whole mapping will be returned.
    @return Name and description for each requested Feature Type

    Parameters:
     - token
     - ref
     - feature_type_list
    """
    pass

  def get_feature_type_counts(token, ref, feature_type_list):
    """
    Retrieve the count of each Feature type.

    @param feature_type_list  List of Feature Types. If empty,
      this will retrieve  counts for all Feature Types.

    Parameters:
     - token
     - ref
     - feature_type_list
    """
    pass

  def get_feature_ids(token, ref, filters, group_type):
    """
    Retrieve Feature IDs, optionally filtered by type, region, function, alias.

    @param filters Dictionary of filters that can be applied to contents.
      If this is empty or missing, all Feature IDs will be returned.
    @param group_type How to group results, which is a single string matching one
      of the values for the ``filters`` parameter.
    @return Grouped mapping of features.

    Parameters:
     - token
     - ref
     - filters
     - group_type
    """
    pass

  def get_features(token, ref, feature_id_list, exclude_sequence):
    """
    Retrieve Feature data.

    @param feature_id_list List of Features to retrieve.
      If None, returns all Feature data.
    @return Mapping from Feature IDs to dicts of available data.

    Parameters:
     - token
     - ref
     - feature_id_list
     - exclude_sequence
    """
    pass

  def get_proteins(token, ref, cds_id_list):
    """
    Retrieve Protein data.

    @return Mapping from protein ID to data about the protein.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    pass

  def get_feature_locations(token, ref, feature_id_list):
    """
    Retrieve Feature locations.

    @param feature_id_list List of Feature IDs for which to retrieve locations.
        If empty, returns data for all features.
    @return Mapping from Feature IDs to location information for each.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_feature_publications(token, ref, feature_id_list):
    """
    Retrieve Feature publications.

    @param feature_id_list List of Feature IDs for which to retrieve publications.
        If empty, returns data for all features.
    @return Mapping from Feature IDs to publication info for each.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_feature_dna(token, ref, feature_id_list):
    """
    Retrieve Feature DNA sequences.

    @param feature_id_list List of Feature IDs for which to retrieve sequences.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to their DNA sequence.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_feature_functions(token, ref, feature_id_list):
    """
    Retrieve Feature functions.

    @param feature_id_list List of Feature IDs for which to retrieve functions.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to their functions.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_feature_aliases(token, ref, feature_id_list):
    """
    Retrieve Feature aliases.

    @param feature_id_list List of Feature IDS for which to retrieve aliases.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to a list of aliases.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    pass

  def get_cds_by_gene(token, ref, gene_id_list):
    """
    Retrieves coding sequence Features (cds) for given gene Feature IDs.

    @param feature_id_list List of gene Feature IDS for which to retrieve CDS.
        If empty, returns data for all features.
    @return Mapping of gene Feature IDs to a list of CDS Feature IDs.

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    pass

  def get_cds_by_mrna(token, ref, mrna_id_list):
    """
    Retrieves coding sequence (cds) Feature IDs for given mRNA Feature IDs.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve CDS.
        If empty, returns data for all features.
    @return Mapping of mRNA Feature IDs to a list of CDS Feature IDs.

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    pass

  def get_gene_by_cds(token, ref, cds_id_list):
    """
    Retrieves gene Feature IDs for given coding sequence (cds) Feature IDs.

    @param feature_id_list List of cds Feature IDS for which to retrieve gene IDs.
        If empty, returns all cds/gene mappings.
    @return Mapping of cds Feature IDs to gene Feature IDs.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    pass

  def get_gene_by_mrna(token, ref, mrna_id_list):
    """
    Retrieves gene Feature IDs for given mRNA Feature IDs.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve gene IDs.
        If empty, returns all mRNA/gene mappings.
    @return Mapping of mRNA Feature IDs to gene Feature IDs.

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    pass

  def get_mrna_by_cds(token, ref, cds_id_list):
    """
    Retrieves mRNA Features for given coding sequences (cds) Feature IDs.

    @param feature_id_list List of cds Feature IDS for which to retrieve mRNA IDs.
        If empty, returns all cds/mRNA mappings.
    @return Mapping of cds Feature IDs to mRNA Feature IDs.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    pass

  def get_mrna_by_gene(token, ref, gene_id_list):
    """
    Retrieve the mRNA IDs for given gene IDs.

    @param feature_id_list List of gene Feature IDS for which to retrieve mRNA IDs.
        If empty, returns all gene/mRNA mappings.
    @return Mapping of gene Feature IDs to a list of mRNA Feature IDs.

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    pass

  def get_mrna_exons(token, ref, mrna_id_list):
    """
    Retrieve Exon information for each mRNA ID.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve exons.
        If empty, returns data for all exons.
    @return Mapping of mRNA Feature IDs to a list of exons (:js:data:`Exon_data`).

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    pass

  def get_mrna_utrs(token, ref, mrna_id_list):
    """
    Retrieve UTR information for each mRNA Feature ID.

     UTRs are calculated between mRNA features and corresponding CDS features.
     The return value for each mRNA can contain either:
        - no UTRs found (empty dict)
        -  5' UTR only
        -  3' UTR only
        -  5' and 3' UTRs

     Note: The Genome data type does not contain interfeature
     relationship information. Calling this method for Genome objects
     will raise a :js:throws:`exc.TypeException`.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve UTRs.
    If empty, returns data for all UTRs.
    @return Mapping of mRNA Feature IDs to a mapping that contains
    both 5' and 3' UTRs::
        { "5'UTR": :js:data:`UTR_data`, "3'UTR": :js:data:`UTR_data` }

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    pass

  def get_summary(token, ref):
    """
    Retrieve a summary representation of this GenomeAnnotation.

    @return summary data

    Parameters:
     - token
     - ref
    """
    pass

  def save_summary(token, ref):
    """
    Retrieve a summary representation of this GenomeAnnotation.

    @return summary data

    Parameters:
     - token
     - ref
    """
    pass


class Client:
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    self._transport = transport
    self._oprot_factory = oprot_factory
    self._seqid = 0
    self._reqs = {}

  def get_taxon(self, token, ref):
    """
    Retrieve the Taxon associated with this GenomeAnnotation.

    @return Reference to TaxonAPI object

    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_taxon, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_taxon,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_taxon,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_taxon(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_taxon(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_taxon(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_taxon', TMessageType.CALL, self._seqid)
    args = get_taxon_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_taxon(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_taxon_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_taxon failed: unknown result"))

  def get_assembly(self, token, ref):
    """
    Retrieve the Assembly associated with this GenomeAnnotation.

    @return Reference to AssemblyAPI object

    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_assembly, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_assembly,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_assembly,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_assembly(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_assembly(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_assembly(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_assembly', TMessageType.CALL, self._seqid)
    args = get_assembly_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_assembly(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_assembly_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_assembly failed: unknown result"))

  def get_feature_types(self, token, ref):
    """
    Retrieve the list of Feature types.

    @return List of feature type identifiers (strings)

    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_types, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_feature_types,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_types,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_types(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_types(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_types(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_types', TMessageType.CALL, self._seqid)
    args = get_feature_types_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_types(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_types_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_types failed: unknown result"))

  def get_feature_type_descriptions(self, token, ref, feature_type_list):
    """
    Retrieve the descriptions for each Feature type in
    this GenomeAnnotation.

    @param feature_type_list List of Feature types. If this list
     is empty or None,
     the whole mapping will be returned.
    @return Name and description for each requested Feature Type

    Parameters:
     - token
     - ref
     - feature_type_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_type_descriptions, token, ref, feature_type_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_type_descriptions,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_type_descriptions,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_type_descriptions(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_type_descriptions(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_type_descriptions(self, token, ref, feature_type_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_type_descriptions', TMessageType.CALL, self._seqid)
    args = get_feature_type_descriptions_args()
    args.token = token
    args.ref = ref
    args.feature_type_list = feature_type_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_type_descriptions(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_type_descriptions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_type_descriptions failed: unknown result"))

  def get_feature_type_counts(self, token, ref, feature_type_list):
    """
    Retrieve the count of each Feature type.

    @param feature_type_list  List of Feature Types. If empty,
      this will retrieve  counts for all Feature Types.

    Parameters:
     - token
     - ref
     - feature_type_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_type_counts, token, ref, feature_type_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_type_counts,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_type_counts,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_type_counts(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_type_counts(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_type_counts(self, token, ref, feature_type_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_type_counts', TMessageType.CALL, self._seqid)
    args = get_feature_type_counts_args()
    args.token = token
    args.ref = ref
    args.feature_type_list = feature_type_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_type_counts(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_type_counts_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_type_counts failed: unknown result"))

  def get_feature_ids(self, token, ref, filters, group_type):
    """
    Retrieve Feature IDs, optionally filtered by type, region, function, alias.

    @param filters Dictionary of filters that can be applied to contents.
      If this is empty or missing, all Feature IDs will be returned.
    @param group_type How to group results, which is a single string matching one
      of the values for the ``filters`` parameter.
    @return Grouped mapping of features.

    Parameters:
     - token
     - ref
     - filters
     - group_type
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_ids, token, ref, filters, group_type)
    d.addCallbacks(
      callback=self.cb_send_get_feature_ids,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_ids,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_ids(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_ids(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_ids(self, token, ref, filters, group_type):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_ids', TMessageType.CALL, self._seqid)
    args = get_feature_ids_args()
    args.token = token
    args.ref = ref
    args.filters = filters
    args.group_type = group_type
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_ids(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_ids failed: unknown result"))

  def get_features(self, token, ref, feature_id_list, exclude_sequence):
    """
    Retrieve Feature data.

    @param feature_id_list List of Features to retrieve.
      If None, returns all Feature data.
    @return Mapping from Feature IDs to dicts of available data.

    Parameters:
     - token
     - ref
     - feature_id_list
     - exclude_sequence
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_features, token, ref, feature_id_list, exclude_sequence)
    d.addCallbacks(
      callback=self.cb_send_get_features,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_features,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_features(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_features(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_features(self, token, ref, feature_id_list, exclude_sequence):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_features', TMessageType.CALL, self._seqid)
    args = get_features_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.exclude_sequence = exclude_sequence
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_features(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_features_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_features failed: unknown result"))

  def get_proteins(self, token, ref, cds_id_list):
    """
    Retrieve Protein data.

    @return Mapping from protein ID to data about the protein.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_proteins, token, ref, cds_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_proteins,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_proteins,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_proteins(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_proteins(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_proteins(self, token, ref, cds_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_proteins', TMessageType.CALL, self._seqid)
    args = get_proteins_args()
    args.token = token
    args.ref = ref
    args.cds_id_list = cds_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_proteins(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_proteins_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_proteins failed: unknown result"))

  def get_feature_locations(self, token, ref, feature_id_list):
    """
    Retrieve Feature locations.

    @param feature_id_list List of Feature IDs for which to retrieve locations.
        If empty, returns data for all features.
    @return Mapping from Feature IDs to location information for each.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_locations, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_locations,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_locations,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_locations(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_locations(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_locations(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_locations', TMessageType.CALL, self._seqid)
    args = get_feature_locations_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_locations(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_locations_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_locations failed: unknown result"))

  def get_feature_publications(self, token, ref, feature_id_list):
    """
    Retrieve Feature publications.

    @param feature_id_list List of Feature IDs for which to retrieve publications.
        If empty, returns data for all features.
    @return Mapping from Feature IDs to publication info for each.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_publications, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_publications,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_publications,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_publications(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_publications(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_publications(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_publications', TMessageType.CALL, self._seqid)
    args = get_feature_publications_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_publications(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_publications_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_publications failed: unknown result"))

  def get_feature_dna(self, token, ref, feature_id_list):
    """
    Retrieve Feature DNA sequences.

    @param feature_id_list List of Feature IDs for which to retrieve sequences.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to their DNA sequence.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_dna, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_dna,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_dna,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_dna(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_dna(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_dna(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_dna', TMessageType.CALL, self._seqid)
    args = get_feature_dna_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_dna(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_dna_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_dna failed: unknown result"))

  def get_feature_functions(self, token, ref, feature_id_list):
    """
    Retrieve Feature functions.

    @param feature_id_list List of Feature IDs for which to retrieve functions.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to their functions.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_functions, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_functions,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_functions,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_functions(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_functions(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_functions(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_functions', TMessageType.CALL, self._seqid)
    args = get_feature_functions_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_functions(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_functions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_functions failed: unknown result"))

  def get_feature_aliases(self, token, ref, feature_id_list):
    """
    Retrieve Feature aliases.

    @param feature_id_list List of Feature IDS for which to retrieve aliases.
        If empty, returns data for all features.
    @return Mapping of Feature IDs to a list of aliases.

    Parameters:
     - token
     - ref
     - feature_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_feature_aliases, token, ref, feature_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_feature_aliases,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_feature_aliases,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_feature_aliases(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_feature_aliases(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_feature_aliases(self, token, ref, feature_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_feature_aliases', TMessageType.CALL, self._seqid)
    args = get_feature_aliases_args()
    args.token = token
    args.ref = ref
    args.feature_id_list = feature_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_feature_aliases(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_feature_aliases_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_feature_aliases failed: unknown result"))

  def get_cds_by_gene(self, token, ref, gene_id_list):
    """
    Retrieves coding sequence Features (cds) for given gene Feature IDs.

    @param feature_id_list List of gene Feature IDS for which to retrieve CDS.
        If empty, returns data for all features.
    @return Mapping of gene Feature IDs to a list of CDS Feature IDs.

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_cds_by_gene, token, ref, gene_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_cds_by_gene,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_cds_by_gene,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_cds_by_gene(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_cds_by_gene(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_cds_by_gene(self, token, ref, gene_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_cds_by_gene', TMessageType.CALL, self._seqid)
    args = get_cds_by_gene_args()
    args.token = token
    args.ref = ref
    args.gene_id_list = gene_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_cds_by_gene(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_cds_by_gene_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_cds_by_gene failed: unknown result"))

  def get_cds_by_mrna(self, token, ref, mrna_id_list):
    """
    Retrieves coding sequence (cds) Feature IDs for given mRNA Feature IDs.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve CDS.
        If empty, returns data for all features.
    @return Mapping of mRNA Feature IDs to a list of CDS Feature IDs.

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_cds_by_mrna, token, ref, mrna_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_cds_by_mrna,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_cds_by_mrna,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_cds_by_mrna(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_cds_by_mrna(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_cds_by_mrna(self, token, ref, mrna_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_cds_by_mrna', TMessageType.CALL, self._seqid)
    args = get_cds_by_mrna_args()
    args.token = token
    args.ref = ref
    args.mrna_id_list = mrna_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_cds_by_mrna(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_cds_by_mrna_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_cds_by_mrna failed: unknown result"))

  def get_gene_by_cds(self, token, ref, cds_id_list):
    """
    Retrieves gene Feature IDs for given coding sequence (cds) Feature IDs.

    @param feature_id_list List of cds Feature IDS for which to retrieve gene IDs.
        If empty, returns all cds/gene mappings.
    @return Mapping of cds Feature IDs to gene Feature IDs.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_gene_by_cds, token, ref, cds_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_gene_by_cds,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_gene_by_cds,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_gene_by_cds(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_gene_by_cds(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_gene_by_cds(self, token, ref, cds_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_gene_by_cds', TMessageType.CALL, self._seqid)
    args = get_gene_by_cds_args()
    args.token = token
    args.ref = ref
    args.cds_id_list = cds_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_gene_by_cds(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_gene_by_cds_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_gene_by_cds failed: unknown result"))

  def get_gene_by_mrna(self, token, ref, mrna_id_list):
    """
    Retrieves gene Feature IDs for given mRNA Feature IDs.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve gene IDs.
        If empty, returns all mRNA/gene mappings.
    @return Mapping of mRNA Feature IDs to gene Feature IDs.

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_gene_by_mrna, token, ref, mrna_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_gene_by_mrna,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_gene_by_mrna,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_gene_by_mrna(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_gene_by_mrna(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_gene_by_mrna(self, token, ref, mrna_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_gene_by_mrna', TMessageType.CALL, self._seqid)
    args = get_gene_by_mrna_args()
    args.token = token
    args.ref = ref
    args.mrna_id_list = mrna_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_gene_by_mrna(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_gene_by_mrna_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_gene_by_mrna failed: unknown result"))

  def get_mrna_by_cds(self, token, ref, cds_id_list):
    """
    Retrieves mRNA Features for given coding sequences (cds) Feature IDs.

    @param feature_id_list List of cds Feature IDS for which to retrieve mRNA IDs.
        If empty, returns all cds/mRNA mappings.
    @return Mapping of cds Feature IDs to mRNA Feature IDs.

    Parameters:
     - token
     - ref
     - cds_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_mrna_by_cds, token, ref, cds_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_mrna_by_cds,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_mrna_by_cds,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_mrna_by_cds(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_mrna_by_cds(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_mrna_by_cds(self, token, ref, cds_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_mrna_by_cds', TMessageType.CALL, self._seqid)
    args = get_mrna_by_cds_args()
    args.token = token
    args.ref = ref
    args.cds_id_list = cds_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_mrna_by_cds(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_mrna_by_cds_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_mrna_by_cds failed: unknown result"))

  def get_mrna_by_gene(self, token, ref, gene_id_list):
    """
    Retrieve the mRNA IDs for given gene IDs.

    @param feature_id_list List of gene Feature IDS for which to retrieve mRNA IDs.
        If empty, returns all gene/mRNA mappings.
    @return Mapping of gene Feature IDs to a list of mRNA Feature IDs.

    Parameters:
     - token
     - ref
     - gene_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_mrna_by_gene, token, ref, gene_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_mrna_by_gene,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_mrna_by_gene,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_mrna_by_gene(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_mrna_by_gene(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_mrna_by_gene(self, token, ref, gene_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_mrna_by_gene', TMessageType.CALL, self._seqid)
    args = get_mrna_by_gene_args()
    args.token = token
    args.ref = ref
    args.gene_id_list = gene_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_mrna_by_gene(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_mrna_by_gene_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_mrna_by_gene failed: unknown result"))

  def get_mrna_exons(self, token, ref, mrna_id_list):
    """
    Retrieve Exon information for each mRNA ID.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve exons.
        If empty, returns data for all exons.
    @return Mapping of mRNA Feature IDs to a list of exons (:js:data:`Exon_data`).

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_mrna_exons, token, ref, mrna_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_mrna_exons,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_mrna_exons,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_mrna_exons(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_mrna_exons(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_mrna_exons(self, token, ref, mrna_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_mrna_exons', TMessageType.CALL, self._seqid)
    args = get_mrna_exons_args()
    args.token = token
    args.ref = ref
    args.mrna_id_list = mrna_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_mrna_exons(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_mrna_exons_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_mrna_exons failed: unknown result"))

  def get_mrna_utrs(self, token, ref, mrna_id_list):
    """
    Retrieve UTR information for each mRNA Feature ID.

     UTRs are calculated between mRNA features and corresponding CDS features.
     The return value for each mRNA can contain either:
        - no UTRs found (empty dict)
        -  5' UTR only
        -  3' UTR only
        -  5' and 3' UTRs

     Note: The Genome data type does not contain interfeature
     relationship information. Calling this method for Genome objects
     will raise a :js:throws:`exc.TypeException`.

    @param feature_id_list List of mRNA Feature IDS for which to retrieve UTRs.
    If empty, returns data for all UTRs.
    @return Mapping of mRNA Feature IDs to a mapping that contains
    both 5' and 3' UTRs::
        { "5'UTR": :js:data:`UTR_data`, "3'UTR": :js:data:`UTR_data` }

    Parameters:
     - token
     - ref
     - mrna_id_list
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_mrna_utrs, token, ref, mrna_id_list)
    d.addCallbacks(
      callback=self.cb_send_get_mrna_utrs,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_mrna_utrs,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_mrna_utrs(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_mrna_utrs(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_mrna_utrs(self, token, ref, mrna_id_list):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_mrna_utrs', TMessageType.CALL, self._seqid)
    args = get_mrna_utrs_args()
    args.token = token
    args.ref = ref
    args.mrna_id_list = mrna_id_list
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_mrna_utrs(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_mrna_utrs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_mrna_utrs failed: unknown result"))

  def get_summary(self, token, ref):
    """
    Retrieve a summary representation of this GenomeAnnotation.

    @return summary data

    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_get_summary, token, ref)
    d.addCallbacks(
      callback=self.cb_send_get_summary,
      callbackArgs=(seqid,),
      errback=self.eb_send_get_summary,
      errbackArgs=(seqid,))
    return d

  def cb_send_get_summary(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_get_summary(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_get_summary(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('get_summary', TMessageType.CALL, self._seqid)
    args = get_summary_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_get_summary(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = get_summary_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "get_summary failed: unknown result"))

  def save_summary(self, token, ref):
    """
    Retrieve a summary representation of this GenomeAnnotation.

    @return summary data

    Parameters:
     - token
     - ref
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_save_summary, token, ref)
    d.addCallbacks(
      callback=self.cb_send_save_summary,
      callbackArgs=(seqid,),
      errback=self.eb_send_save_summary,
      errbackArgs=(seqid,))
    return d

  def cb_send_save_summary(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_save_summary(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_save_summary(self, token, ref):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('save_summary', TMessageType.CALL, self._seqid)
    args = save_summary_args()
    args.token = token
    args.ref = ref
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_save_summary(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = save_summary_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.generic_exception is not None:
      return d.errback(result.generic_exception)
    if result.authorization_exception is not None:
      return d.errback(result.authorization_exception)
    if result.authentication_exception is not None:
      return d.errback(result.authentication_exception)
    if result.reference_exception is not None:
      return d.errback(result.reference_exception)
    if result.attribute_exception is not None:
      return d.errback(result.attribute_exception)
    if result.type_exception is not None:
      return d.errback(result.type_exception)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "save_summary failed: unknown result"))


class Processor(TProcessor):
  implements(Iface)

  def __init__(self, handler):
    self._handler = Iface(handler)
    self._processMap = {}
    self._processMap["get_taxon"] = Processor.process_get_taxon
    self._processMap["get_assembly"] = Processor.process_get_assembly
    self._processMap["get_feature_types"] = Processor.process_get_feature_types
    self._processMap["get_feature_type_descriptions"] = Processor.process_get_feature_type_descriptions
    self._processMap["get_feature_type_counts"] = Processor.process_get_feature_type_counts
    self._processMap["get_feature_ids"] = Processor.process_get_feature_ids
    self._processMap["get_features"] = Processor.process_get_features
    self._processMap["get_proteins"] = Processor.process_get_proteins
    self._processMap["get_feature_locations"] = Processor.process_get_feature_locations
    self._processMap["get_feature_publications"] = Processor.process_get_feature_publications
    self._processMap["get_feature_dna"] = Processor.process_get_feature_dna
    self._processMap["get_feature_functions"] = Processor.process_get_feature_functions
    self._processMap["get_feature_aliases"] = Processor.process_get_feature_aliases
    self._processMap["get_cds_by_gene"] = Processor.process_get_cds_by_gene
    self._processMap["get_cds_by_mrna"] = Processor.process_get_cds_by_mrna
    self._processMap["get_gene_by_cds"] = Processor.process_get_gene_by_cds
    self._processMap["get_gene_by_mrna"] = Processor.process_get_gene_by_mrna
    self._processMap["get_mrna_by_cds"] = Processor.process_get_mrna_by_cds
    self._processMap["get_mrna_by_gene"] = Processor.process_get_mrna_by_gene
    self._processMap["get_mrna_exons"] = Processor.process_get_mrna_exons
    self._processMap["get_mrna_utrs"] = Processor.process_get_mrna_utrs
    self._processMap["get_summary"] = Processor.process_get_summary
    self._processMap["save_summary"] = Processor.process_save_summary

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_get_taxon(self, seqid, iprot, oprot):
    args = get_taxon_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_taxon_result()
    d = defer.maybeDeferred(self._handler.get_taxon, args.token, args.ref)
    d.addCallback(self.write_results_success_get_taxon, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_taxon, result, seqid, oprot)
    return d

  def write_results_success_get_taxon(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_taxon", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_taxon(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_taxon", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_assembly(self, seqid, iprot, oprot):
    args = get_assembly_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_assembly_result()
    d = defer.maybeDeferred(self._handler.get_assembly, args.token, args.ref)
    d.addCallback(self.write_results_success_get_assembly, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_assembly, result, seqid, oprot)
    return d

  def write_results_success_get_assembly(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_assembly", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_assembly(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_assembly", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_types(self, seqid, iprot, oprot):
    args = get_feature_types_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_types_result()
    d = defer.maybeDeferred(self._handler.get_feature_types, args.token, args.ref)
    d.addCallback(self.write_results_success_get_feature_types, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_types, result, seqid, oprot)
    return d

  def write_results_success_get_feature_types(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_types", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_types(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_types", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_type_descriptions(self, seqid, iprot, oprot):
    args = get_feature_type_descriptions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_type_descriptions_result()
    d = defer.maybeDeferred(self._handler.get_feature_type_descriptions, args.token, args.ref, args.feature_type_list)
    d.addCallback(self.write_results_success_get_feature_type_descriptions, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_type_descriptions, result, seqid, oprot)
    return d

  def write_results_success_get_feature_type_descriptions(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_type_descriptions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_type_descriptions(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_type_descriptions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_type_counts(self, seqid, iprot, oprot):
    args = get_feature_type_counts_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_type_counts_result()
    d = defer.maybeDeferred(self._handler.get_feature_type_counts, args.token, args.ref, args.feature_type_list)
    d.addCallback(self.write_results_success_get_feature_type_counts, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_type_counts, result, seqid, oprot)
    return d

  def write_results_success_get_feature_type_counts(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_type_counts", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_type_counts(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_type_counts", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_ids(self, seqid, iprot, oprot):
    args = get_feature_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_ids_result()
    d = defer.maybeDeferred(self._handler.get_feature_ids, args.token, args.ref, args.filters, args.group_type)
    d.addCallback(self.write_results_success_get_feature_ids, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_ids, result, seqid, oprot)
    return d

  def write_results_success_get_feature_ids(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_ids(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_features(self, seqid, iprot, oprot):
    args = get_features_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_features_result()
    d = defer.maybeDeferred(self._handler.get_features, args.token, args.ref, args.feature_id_list, args.exclude_sequence)
    d.addCallback(self.write_results_success_get_features, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_features, result, seqid, oprot)
    return d

  def write_results_success_get_features(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_features", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_features(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_features", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_proteins(self, seqid, iprot, oprot):
    args = get_proteins_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_proteins_result()
    d = defer.maybeDeferred(self._handler.get_proteins, args.token, args.ref, args.cds_id_list)
    d.addCallback(self.write_results_success_get_proteins, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_proteins, result, seqid, oprot)
    return d

  def write_results_success_get_proteins(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_proteins", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_proteins(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_proteins", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_locations(self, seqid, iprot, oprot):
    args = get_feature_locations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_locations_result()
    d = defer.maybeDeferred(self._handler.get_feature_locations, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_locations, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_locations, result, seqid, oprot)
    return d

  def write_results_success_get_feature_locations(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_locations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_locations(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_locations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_publications(self, seqid, iprot, oprot):
    args = get_feature_publications_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_publications_result()
    d = defer.maybeDeferred(self._handler.get_feature_publications, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_publications, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_publications, result, seqid, oprot)
    return d

  def write_results_success_get_feature_publications(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_publications", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_publications(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_publications", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_dna(self, seqid, iprot, oprot):
    args = get_feature_dna_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_dna_result()
    d = defer.maybeDeferred(self._handler.get_feature_dna, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_dna, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_dna, result, seqid, oprot)
    return d

  def write_results_success_get_feature_dna(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_dna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_dna(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_dna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_functions(self, seqid, iprot, oprot):
    args = get_feature_functions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_functions_result()
    d = defer.maybeDeferred(self._handler.get_feature_functions, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_functions, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_functions, result, seqid, oprot)
    return d

  def write_results_success_get_feature_functions(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_functions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_functions(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_functions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_feature_aliases(self, seqid, iprot, oprot):
    args = get_feature_aliases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_feature_aliases_result()
    d = defer.maybeDeferred(self._handler.get_feature_aliases, args.token, args.ref, args.feature_id_list)
    d.addCallback(self.write_results_success_get_feature_aliases, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_feature_aliases, result, seqid, oprot)
    return d

  def write_results_success_get_feature_aliases(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_feature_aliases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_feature_aliases(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_feature_aliases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_cds_by_gene(self, seqid, iprot, oprot):
    args = get_cds_by_gene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_cds_by_gene_result()
    d = defer.maybeDeferred(self._handler.get_cds_by_gene, args.token, args.ref, args.gene_id_list)
    d.addCallback(self.write_results_success_get_cds_by_gene, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_cds_by_gene, result, seqid, oprot)
    return d

  def write_results_success_get_cds_by_gene(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_cds_by_gene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_cds_by_gene(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_cds_by_gene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_cds_by_mrna(self, seqid, iprot, oprot):
    args = get_cds_by_mrna_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_cds_by_mrna_result()
    d = defer.maybeDeferred(self._handler.get_cds_by_mrna, args.token, args.ref, args.mrna_id_list)
    d.addCallback(self.write_results_success_get_cds_by_mrna, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_cds_by_mrna, result, seqid, oprot)
    return d

  def write_results_success_get_cds_by_mrna(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_cds_by_mrna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_cds_by_mrna(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_cds_by_mrna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_gene_by_cds(self, seqid, iprot, oprot):
    args = get_gene_by_cds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_gene_by_cds_result()
    d = defer.maybeDeferred(self._handler.get_gene_by_cds, args.token, args.ref, args.cds_id_list)
    d.addCallback(self.write_results_success_get_gene_by_cds, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_gene_by_cds, result, seqid, oprot)
    return d

  def write_results_success_get_gene_by_cds(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_gene_by_cds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_gene_by_cds(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_gene_by_cds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_gene_by_mrna(self, seqid, iprot, oprot):
    args = get_gene_by_mrna_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_gene_by_mrna_result()
    d = defer.maybeDeferred(self._handler.get_gene_by_mrna, args.token, args.ref, args.mrna_id_list)
    d.addCallback(self.write_results_success_get_gene_by_mrna, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_gene_by_mrna, result, seqid, oprot)
    return d

  def write_results_success_get_gene_by_mrna(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_gene_by_mrna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_gene_by_mrna(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_gene_by_mrna", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mrna_by_cds(self, seqid, iprot, oprot):
    args = get_mrna_by_cds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mrna_by_cds_result()
    d = defer.maybeDeferred(self._handler.get_mrna_by_cds, args.token, args.ref, args.cds_id_list)
    d.addCallback(self.write_results_success_get_mrna_by_cds, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_mrna_by_cds, result, seqid, oprot)
    return d

  def write_results_success_get_mrna_by_cds(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_mrna_by_cds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_mrna_by_cds(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_mrna_by_cds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mrna_by_gene(self, seqid, iprot, oprot):
    args = get_mrna_by_gene_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mrna_by_gene_result()
    d = defer.maybeDeferred(self._handler.get_mrna_by_gene, args.token, args.ref, args.gene_id_list)
    d.addCallback(self.write_results_success_get_mrna_by_gene, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_mrna_by_gene, result, seqid, oprot)
    return d

  def write_results_success_get_mrna_by_gene(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_mrna_by_gene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_mrna_by_gene(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_mrna_by_gene", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mrna_exons(self, seqid, iprot, oprot):
    args = get_mrna_exons_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mrna_exons_result()
    d = defer.maybeDeferred(self._handler.get_mrna_exons, args.token, args.ref, args.mrna_id_list)
    d.addCallback(self.write_results_success_get_mrna_exons, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_mrna_exons, result, seqid, oprot)
    return d

  def write_results_success_get_mrna_exons(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_mrna_exons", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_mrna_exons(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_mrna_exons", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mrna_utrs(self, seqid, iprot, oprot):
    args = get_mrna_utrs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mrna_utrs_result()
    d = defer.maybeDeferred(self._handler.get_mrna_utrs, args.token, args.ref, args.mrna_id_list)
    d.addCallback(self.write_results_success_get_mrna_utrs, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_mrna_utrs, result, seqid, oprot)
    return d

  def write_results_success_get_mrna_utrs(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_mrna_utrs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_mrna_utrs(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_mrna_utrs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_summary(self, seqid, iprot, oprot):
    args = get_summary_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_summary_result()
    d = defer.maybeDeferred(self._handler.get_summary, args.token, args.ref)
    d.addCallback(self.write_results_success_get_summary, result, seqid, oprot)
    d.addErrback(self.write_results_exception_get_summary, result, seqid, oprot)
    return d

  def write_results_success_get_summary(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("get_summary", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_get_summary(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("get_summary", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_save_summary(self, seqid, iprot, oprot):
    args = save_summary_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = save_summary_result()
    d = defer.maybeDeferred(self._handler.save_summary, args.token, args.ref)
    d.addCallback(self.write_results_success_save_summary, result, seqid, oprot)
    d.addErrback(self.write_results_exception_save_summary, result, seqid, oprot)
    return d

  def write_results_success_save_summary(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("save_summary", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_save_summary(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except ServiceException, generic_exception:
      result.generic_exception = generic_exception
    except AuthorizationException, authorization_exception:
      result.authorization_exception = authorization_exception
    except AuthenticationException, authentication_exception:
      result.authentication_exception = authentication_exception
    except ObjectReferenceException, reference_exception:
      result.reference_exception = reference_exception
    except AttributeException, attribute_exception:
      result.attribute_exception = attribute_exception
    except TypeException, type_exception:
      result.type_exception = type_exception
    oprot.writeMessageBegin("save_summary", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_taxon_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_taxon_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_taxon_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_taxon_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_assembly_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_assembly_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_assembly_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_assembly_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_types_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_types_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_types_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype224, _size221) = iprot.readListBegin()
          for _i225 in xrange(_size221):
            _elem226 = iprot.readString();
            self.success.append(_elem226)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_types_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter227 in self.success:
        oprot.writeString(iter227)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_type_descriptions_args:
  """
  Attributes:
   - token
   - ref
   - feature_type_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_type_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_type_list=None,):
    self.token = token
    self.ref = ref
    self.feature_type_list = feature_type_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_type_list = []
          (_etype231, _size228) = iprot.readListBegin()
          for _i232 in xrange(_size228):
            _elem233 = iprot.readString();
            self.feature_type_list.append(_elem233)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_type_descriptions_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_type_list is not None:
      oprot.writeFieldBegin('feature_type_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_type_list))
      for iter234 in self.feature_type_list:
        oprot.writeString(iter234)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_type_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_type_descriptions_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype236, _vtype237, _size235 ) = iprot.readMapBegin()
          for _i239 in xrange(_size235):
            _key240 = iprot.readString();
            _val241 = iprot.readString();
            self.success[_key240] = _val241
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_type_descriptions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter242,viter243 in self.success.items():
        oprot.writeString(kiter242)
        oprot.writeString(viter243)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_type_counts_args:
  """
  Attributes:
   - token
   - ref
   - feature_type_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_type_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_type_list=None,):
    self.token = token
    self.ref = ref
    self.feature_type_list = feature_type_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_type_list = []
          (_etype247, _size244) = iprot.readListBegin()
          for _i248 in xrange(_size244):
            _elem249 = iprot.readString();
            self.feature_type_list.append(_elem249)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_type_counts_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_type_list is not None:
      oprot.writeFieldBegin('feature_type_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_type_list))
      for iter250 in self.feature_type_list:
        oprot.writeString(iter250)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_type_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_type_counts_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype252, _vtype253, _size251 ) = iprot.readMapBegin()
          for _i255 in xrange(_size251):
            _key256 = iprot.readString();
            _val257 = iprot.readI64();
            self.success[_key256] = _val257
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_type_counts_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
      for kiter258,viter259 in self.success.items():
        oprot.writeString(kiter258)
        oprot.writeI64(viter259)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_ids_args:
  """
  Attributes:
   - token
   - ref
   - filters
   - group_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRUCT, 'filters', (Feature_id_filters, Feature_id_filters.thrift_spec), None, ), # 3
    (4, TType.STRING, 'group_type', None, None, ), # 4
  )

  def __init__(self, token=None, ref=None, filters=None, group_type=None,):
    self.token = token
    self.ref = ref
    self.filters = filters
    self.group_type = group_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.filters = Feature_id_filters()
          self.filters.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.group_type = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_ids_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.filters is not None:
      oprot.writeFieldBegin('filters', TType.STRUCT, 3)
      self.filters.write(oprot)
      oprot.writeFieldEnd()
    if self.group_type is not None:
      oprot.writeFieldBegin('group_type', TType.STRING, 4)
      oprot.writeString(self.group_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.filters)
    value = (value * 31) ^ hash(self.group_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_ids_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Feature_id_mapping, Feature_id_mapping.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Feature_id_mapping()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_features_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
   - exclude_sequence
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'exclude_sequence', None, None, ), # 4
  )

  def __init__(self, token=None, ref=None, feature_id_list=None, exclude_sequence=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list
    self.exclude_sequence = exclude_sequence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype263, _size260) = iprot.readListBegin()
          for _i264 in xrange(_size260):
            _elem265 = iprot.readString();
            self.feature_id_list.append(_elem265)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.exclude_sequence = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_features_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter266 in self.feature_id_list:
        oprot.writeString(iter266)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exclude_sequence is not None:
      oprot.writeFieldBegin('exclude_sequence', TType.BOOL, 4)
      oprot.writeBool(self.exclude_sequence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    value = (value * 31) ^ hash(self.exclude_sequence)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_features_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Feature_data, Feature_data.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype268, _vtype269, _size267 ) = iprot.readMapBegin()
          for _i271 in xrange(_size267):
            _key272 = iprot.readString();
            _val273 = Feature_data()
            _val273.read(iprot)
            self.success[_key272] = _val273
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_features_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter274,viter275 in self.success.items():
        oprot.writeString(kiter274)
        viter275.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_proteins_args:
  """
  Attributes:
   - token
   - ref
   - cds_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'cds_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, cds_id_list=None,):
    self.token = token
    self.ref = ref
    self.cds_id_list = cds_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.cds_id_list = []
          (_etype279, _size276) = iprot.readListBegin()
          for _i280 in xrange(_size276):
            _elem281 = iprot.readString();
            self.cds_id_list.append(_elem281)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_proteins_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.cds_id_list is not None:
      oprot.writeFieldBegin('cds_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.cds_id_list))
      for iter282 in self.cds_id_list:
        oprot.writeString(iter282)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.cds_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_proteins_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Protein_data, Protein_data.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype284, _vtype285, _size283 ) = iprot.readMapBegin()
          for _i287 in xrange(_size283):
            _key288 = iprot.readString();
            _val289 = Protein_data()
            _val289.read(iprot)
            self.success[_key288] = _val289
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_proteins_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter290,viter291 in self.success.items():
        oprot.writeString(kiter290)
        viter291.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_locations_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype295, _size292) = iprot.readListBegin()
          for _i296 in xrange(_size292):
            _elem297 = iprot.readString();
            self.feature_id_list.append(_elem297)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_locations_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter298 in self.feature_id_list:
        oprot.writeString(iter298)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_locations_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Region, Region.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype300, _vtype301, _size299 ) = iprot.readMapBegin()
          for _i303 in xrange(_size299):
            _key304 = iprot.readString();
            _val305 = []
            (_etype309, _size306) = iprot.readListBegin()
            for _i310 in xrange(_size306):
              _elem311 = Region()
              _elem311.read(iprot)
              _val305.append(_elem311)
            iprot.readListEnd()
            self.success[_key304] = _val305
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_locations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter312,viter313 in self.success.items():
        oprot.writeString(kiter312)
        oprot.writeListBegin(TType.STRUCT, len(viter313))
        for iter314 in viter313:
          iter314.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_publications_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype318, _size315) = iprot.readListBegin()
          for _i319 in xrange(_size315):
            _elem320 = iprot.readString();
            self.feature_id_list.append(_elem320)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_publications_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter321 in self.feature_id_list:
        oprot.writeString(iter321)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_publications_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype323, _vtype324, _size322 ) = iprot.readMapBegin()
          for _i326 in xrange(_size322):
            _key327 = iprot.readString();
            _val328 = []
            (_etype332, _size329) = iprot.readListBegin()
            for _i333 in xrange(_size329):
              _elem334 = iprot.readString();
              _val328.append(_elem334)
            iprot.readListEnd()
            self.success[_key327] = _val328
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_publications_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter335,viter336 in self.success.items():
        oprot.writeString(kiter335)
        oprot.writeListBegin(TType.STRING, len(viter336))
        for iter337 in viter336:
          oprot.writeString(iter337)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_dna_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype341, _size338) = iprot.readListBegin()
          for _i342 in xrange(_size338):
            _elem343 = iprot.readString();
            self.feature_id_list.append(_elem343)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_dna_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter344 in self.feature_id_list:
        oprot.writeString(iter344)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_dna_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype346, _vtype347, _size345 ) = iprot.readMapBegin()
          for _i349 in xrange(_size345):
            _key350 = iprot.readString();
            _val351 = iprot.readString();
            self.success[_key350] = _val351
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_dna_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter352,viter353 in self.success.items():
        oprot.writeString(kiter352)
        oprot.writeString(viter353)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_functions_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype357, _size354) = iprot.readListBegin()
          for _i358 in xrange(_size354):
            _elem359 = iprot.readString();
            self.feature_id_list.append(_elem359)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_functions_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter360 in self.feature_id_list:
        oprot.writeString(iter360)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_functions_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype362, _vtype363, _size361 ) = iprot.readMapBegin()
          for _i365 in xrange(_size361):
            _key366 = iprot.readString();
            _val367 = iprot.readString();
            self.success[_key366] = _val367
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_functions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter368,viter369 in self.success.items():
        oprot.writeString(kiter368)
        oprot.writeString(viter369)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_aliases_args:
  """
  Attributes:
   - token
   - ref
   - feature_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'feature_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, feature_id_list=None,):
    self.token = token
    self.ref = ref
    self.feature_id_list = feature_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.feature_id_list = []
          (_etype373, _size370) = iprot.readListBegin()
          for _i374 in xrange(_size370):
            _elem375 = iprot.readString();
            self.feature_id_list.append(_elem375)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_aliases_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.feature_id_list is not None:
      oprot.writeFieldBegin('feature_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.feature_id_list))
      for iter376 in self.feature_id_list:
        oprot.writeString(iter376)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.feature_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_feature_aliases_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype378, _vtype379, _size377 ) = iprot.readMapBegin()
          for _i381 in xrange(_size377):
            _key382 = iprot.readString();
            _val383 = []
            (_etype387, _size384) = iprot.readListBegin()
            for _i388 in xrange(_size384):
              _elem389 = iprot.readString();
              _val383.append(_elem389)
            iprot.readListEnd()
            self.success[_key382] = _val383
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_feature_aliases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter390,viter391 in self.success.items():
        oprot.writeString(kiter390)
        oprot.writeListBegin(TType.STRING, len(viter391))
        for iter392 in viter391:
          oprot.writeString(iter392)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_cds_by_gene_args:
  """
  Attributes:
   - token
   - ref
   - gene_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'gene_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, gene_id_list=None,):
    self.token = token
    self.ref = ref
    self.gene_id_list = gene_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.gene_id_list = []
          (_etype396, _size393) = iprot.readListBegin()
          for _i397 in xrange(_size393):
            _elem398 = iprot.readString();
            self.gene_id_list.append(_elem398)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_cds_by_gene_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.gene_id_list is not None:
      oprot.writeFieldBegin('gene_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.gene_id_list))
      for iter399 in self.gene_id_list:
        oprot.writeString(iter399)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.gene_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_cds_by_gene_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype401, _vtype402, _size400 ) = iprot.readMapBegin()
          for _i404 in xrange(_size400):
            _key405 = iprot.readString();
            _val406 = []
            (_etype410, _size407) = iprot.readListBegin()
            for _i411 in xrange(_size407):
              _elem412 = iprot.readString();
              _val406.append(_elem412)
            iprot.readListEnd()
            self.success[_key405] = _val406
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_cds_by_gene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter413,viter414 in self.success.items():
        oprot.writeString(kiter413)
        oprot.writeListBegin(TType.STRING, len(viter414))
        for iter415 in viter414:
          oprot.writeString(iter415)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_cds_by_mrna_args:
  """
  Attributes:
   - token
   - ref
   - mrna_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'mrna_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, mrna_id_list=None,):
    self.token = token
    self.ref = ref
    self.mrna_id_list = mrna_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mrna_id_list = []
          (_etype419, _size416) = iprot.readListBegin()
          for _i420 in xrange(_size416):
            _elem421 = iprot.readString();
            self.mrna_id_list.append(_elem421)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_cds_by_mrna_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.mrna_id_list is not None:
      oprot.writeFieldBegin('mrna_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.mrna_id_list))
      for iter422 in self.mrna_id_list:
        oprot.writeString(iter422)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.mrna_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_cds_by_mrna_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype424, _vtype425, _size423 ) = iprot.readMapBegin()
          for _i427 in xrange(_size423):
            _key428 = iprot.readString();
            _val429 = iprot.readString();
            self.success[_key428] = _val429
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_cds_by_mrna_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter430,viter431 in self.success.items():
        oprot.writeString(kiter430)
        oprot.writeString(viter431)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gene_by_cds_args:
  """
  Attributes:
   - token
   - ref
   - cds_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'cds_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, cds_id_list=None,):
    self.token = token
    self.ref = ref
    self.cds_id_list = cds_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.cds_id_list = []
          (_etype435, _size432) = iprot.readListBegin()
          for _i436 in xrange(_size432):
            _elem437 = iprot.readString();
            self.cds_id_list.append(_elem437)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gene_by_cds_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.cds_id_list is not None:
      oprot.writeFieldBegin('cds_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.cds_id_list))
      for iter438 in self.cds_id_list:
        oprot.writeString(iter438)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.cds_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gene_by_cds_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype440, _vtype441, _size439 ) = iprot.readMapBegin()
          for _i443 in xrange(_size439):
            _key444 = iprot.readString();
            _val445 = iprot.readString();
            self.success[_key444] = _val445
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gene_by_cds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter446,viter447 in self.success.items():
        oprot.writeString(kiter446)
        oprot.writeString(viter447)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gene_by_mrna_args:
  """
  Attributes:
   - token
   - ref
   - mrna_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'mrna_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, mrna_id_list=None,):
    self.token = token
    self.ref = ref
    self.mrna_id_list = mrna_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mrna_id_list = []
          (_etype451, _size448) = iprot.readListBegin()
          for _i452 in xrange(_size448):
            _elem453 = iprot.readString();
            self.mrna_id_list.append(_elem453)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gene_by_mrna_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.mrna_id_list is not None:
      oprot.writeFieldBegin('mrna_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.mrna_id_list))
      for iter454 in self.mrna_id_list:
        oprot.writeString(iter454)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.mrna_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_gene_by_mrna_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype456, _vtype457, _size455 ) = iprot.readMapBegin()
          for _i459 in xrange(_size455):
            _key460 = iprot.readString();
            _val461 = iprot.readString();
            self.success[_key460] = _val461
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_gene_by_mrna_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter462,viter463 in self.success.items():
        oprot.writeString(kiter462)
        oprot.writeString(viter463)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_by_cds_args:
  """
  Attributes:
   - token
   - ref
   - cds_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'cds_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, cds_id_list=None,):
    self.token = token
    self.ref = ref
    self.cds_id_list = cds_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.cds_id_list = []
          (_etype467, _size464) = iprot.readListBegin()
          for _i468 in xrange(_size464):
            _elem469 = iprot.readString();
            self.cds_id_list.append(_elem469)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_by_cds_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.cds_id_list is not None:
      oprot.writeFieldBegin('cds_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.cds_id_list))
      for iter470 in self.cds_id_list:
        oprot.writeString(iter470)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.cds_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_by_cds_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype472, _vtype473, _size471 ) = iprot.readMapBegin()
          for _i475 in xrange(_size471):
            _key476 = iprot.readString();
            _val477 = iprot.readString();
            self.success[_key476] = _val477
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_by_cds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter478,viter479 in self.success.items():
        oprot.writeString(kiter478)
        oprot.writeString(viter479)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_by_gene_args:
  """
  Attributes:
   - token
   - ref
   - gene_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'gene_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, gene_id_list=None,):
    self.token = token
    self.ref = ref
    self.gene_id_list = gene_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.gene_id_list = []
          (_etype483, _size480) = iprot.readListBegin()
          for _i484 in xrange(_size480):
            _elem485 = iprot.readString();
            self.gene_id_list.append(_elem485)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_by_gene_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.gene_id_list is not None:
      oprot.writeFieldBegin('gene_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.gene_id_list))
      for iter486 in self.gene_id_list:
        oprot.writeString(iter486)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.gene_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_by_gene_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype488, _vtype489, _size487 ) = iprot.readMapBegin()
          for _i491 in xrange(_size487):
            _key492 = iprot.readString();
            _val493 = []
            (_etype497, _size494) = iprot.readListBegin()
            for _i498 in xrange(_size494):
              _elem499 = iprot.readString();
              _val493.append(_elem499)
            iprot.readListEnd()
            self.success[_key492] = _val493
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_by_gene_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter500,viter501 in self.success.items():
        oprot.writeString(kiter500)
        oprot.writeListBegin(TType.STRING, len(viter501))
        for iter502 in viter501:
          oprot.writeString(iter502)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_exons_args:
  """
  Attributes:
   - token
   - ref
   - mrna_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'mrna_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, mrna_id_list=None,):
    self.token = token
    self.ref = ref
    self.mrna_id_list = mrna_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mrna_id_list = []
          (_etype506, _size503) = iprot.readListBegin()
          for _i507 in xrange(_size503):
            _elem508 = iprot.readString();
            self.mrna_id_list.append(_elem508)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_exons_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.mrna_id_list is not None:
      oprot.writeFieldBegin('mrna_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.mrna_id_list))
      for iter509 in self.mrna_id_list:
        oprot.writeString(iter509)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.mrna_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_exons_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Exon_data, Exon_data.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype511, _vtype512, _size510 ) = iprot.readMapBegin()
          for _i514 in xrange(_size510):
            _key515 = iprot.readString();
            _val516 = []
            (_etype520, _size517) = iprot.readListBegin()
            for _i521 in xrange(_size517):
              _elem522 = Exon_data()
              _elem522.read(iprot)
              _val516.append(_elem522)
            iprot.readListEnd()
            self.success[_key515] = _val516
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_exons_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter523,viter524 in self.success.items():
        oprot.writeString(kiter523)
        oprot.writeListBegin(TType.STRUCT, len(viter524))
        for iter525 in viter524:
          iter525.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_utrs_args:
  """
  Attributes:
   - token
   - ref
   - mrna_id_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.LIST, 'mrna_id_list', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, token=None, ref=None, mrna_id_list=None,):
    self.token = token
    self.ref = ref
    self.mrna_id_list = mrna_id_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mrna_id_list = []
          (_etype529, _size526) = iprot.readListBegin()
          for _i530 in xrange(_size526):
            _elem531 = iprot.readString();
            self.mrna_id_list.append(_elem531)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_utrs_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.mrna_id_list is not None:
      oprot.writeFieldBegin('mrna_id_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.mrna_id_list))
      for iter532 in self.mrna_id_list:
        oprot.writeString(iter532)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    value = (value * 31) ^ hash(self.mrna_id_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mrna_utrs_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(UTR_data, UTR_data.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype534, _vtype535, _size533 ) = iprot.readMapBegin()
          for _i537 in xrange(_size533):
            _key538 = iprot.readString();
            _val539 = {}
            (_ktype541, _vtype542, _size540 ) = iprot.readMapBegin()
            for _i544 in xrange(_size540):
              _key545 = iprot.readString();
              _val546 = UTR_data()
              _val546.read(iprot)
              _val539[_key545] = _val546
            iprot.readMapEnd()
            self.success[_key538] = _val539
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mrna_utrs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter547,viter548 in self.success.items():
        oprot.writeString(kiter547)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter548))
        for kiter549,viter550 in viter548.items():
          oprot.writeString(kiter549)
          viter550.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_summary_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_summary_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_summary_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Summary_data, Summary_data.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Summary_data()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_summary_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class save_summary_args:
  """
  Attributes:
   - token
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, token=None, ref=None,):
    self.token = token
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('save_summary_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.ref is None:
      raise TProtocol.TProtocolException(message='Required field ref is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.ref)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class save_summary_result:
  """
  Attributes:
   - success
   - generic_exception
   - authorization_exception
   - authentication_exception
   - reference_exception
   - attribute_exception
   - type_exception
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'generic_exception', (ServiceException, ServiceException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'authorization_exception', (AuthorizationException, AuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'authentication_exception', (AuthenticationException, AuthenticationException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'reference_exception', (ObjectReferenceException, ObjectReferenceException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'attribute_exception', (AttributeException, AttributeException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'type_exception', (TypeException, TypeException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, generic_exception=None, authorization_exception=None, authentication_exception=None, reference_exception=None, attribute_exception=None, type_exception=None,):
    self.success = success
    self.generic_exception = generic_exception
    self.authorization_exception = authorization_exception
    self.authentication_exception = authentication_exception
    self.reference_exception = reference_exception
    self.attribute_exception = attribute_exception
    self.type_exception = type_exception

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.generic_exception = ServiceException()
          self.generic_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.authorization_exception = AuthorizationException()
          self.authorization_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.authentication_exception = AuthenticationException()
          self.authentication_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.reference_exception = ObjectReferenceException()
          self.reference_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.attribute_exception = AttributeException()
          self.attribute_exception.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.type_exception = TypeException()
          self.type_exception.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('save_summary_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.generic_exception is not None:
      oprot.writeFieldBegin('generic_exception', TType.STRUCT, 1)
      self.generic_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authorization_exception is not None:
      oprot.writeFieldBegin('authorization_exception', TType.STRUCT, 2)
      self.authorization_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.authentication_exception is not None:
      oprot.writeFieldBegin('authentication_exception', TType.STRUCT, 3)
      self.authentication_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_exception is not None:
      oprot.writeFieldBegin('reference_exception', TType.STRUCT, 4)
      self.reference_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.attribute_exception is not None:
      oprot.writeFieldBegin('attribute_exception', TType.STRUCT, 5)
      self.attribute_exception.write(oprot)
      oprot.writeFieldEnd()
    if self.type_exception is not None:
      oprot.writeFieldBegin('type_exception', TType.STRUCT, 6)
      self.type_exception.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.generic_exception)
    value = (value * 31) ^ hash(self.authorization_exception)
    value = (value * 31) ^ hash(self.authentication_exception)
    value = (value * 31) ^ hash(self.reference_exception)
    value = (value * 31) ^ hash(self.attribute_exception)
    value = (value * 31) ^ hash(self.type_exception)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
